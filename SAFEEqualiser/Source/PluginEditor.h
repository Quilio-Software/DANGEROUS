/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#ifndef PLUGINEDITOR_H_INCLUDED
#define PLUGINEDITOR_H_INCLUDED

#include <JuceHeader.h>
#include "PluginProcessor.h"

using namespace juce;

//==============================================================================
/**
*/
class LabelledSliderWidget : public juce::Component
{
    juce::Label label;
    juce::Slider slider;
    juce::String labelText;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> sliderAttachment;

    juce::AudioProcessorValueTreeState& valueTreeState;

    int textBoxHeight = 10;
    int labelHeight = 30;

public:
    LabelledSliderWidget (juce::String parameterID, juce::String newLabelText, juce::AudioProcessorValueTreeState& vts) : valueTreeState (vts)
    {
        labelText = newLabelText;

        addAndMakeVisible (slider);
        slider.setSliderStyle (juce::Slider::SliderStyle::RotaryVerticalDrag);
        slider.setTextBoxStyle (juce::Slider::TextEntryBoxPosition::TextBoxBelow, false, 100, textBoxHeight);
        slider.setColour (juce::Slider::textBoxOutlineColourId, juce::Colours::transparentBlack);
        slider.setNumDecimalPlacesToDisplay (1);
        juce::String suffix = getParameterUnits (vts, parameterID);
        slider.setTextValueSuffix (suffix);
        slider.setColour (juce::Slider::textBoxTextColourId, juce::Colours::red);

        addAndMakeVisible (label);
        label.setText (labelText, juce::dontSendNotification);
        label.setJustificationType (juce::Justification::centred);
        label.setColour (juce::Label::textColourId, juce::Colours::red);

        // Create SliderAttachments for all parameters
        sliderAttachment.reset (new juce::AudioProcessorValueTreeState::SliderAttachment (valueTreeState, parameterID, slider));
    }

    void setSliderStyle(juce::Slider::SliderStyle sliderStyle)
    {
        slider.setSliderStyle (sliderStyle);
    }

    juce::String getParameterUnits (juce::AudioProcessorValueTreeState& state, juce::String parameterID)
    {
        // Get the parameter object from the value tree state
        auto* param = state.getParameter (parameterID);

        // Get the label text for the parameter
        auto labelText = param->getLabel();

        // Parse the label text to extract the units
        auto units = labelText.fromLastOccurrenceOf(" ", false, true);

        // Return the units
        return units;
    }

    void paint (juce::Graphics& g) override
    {
    }

    void resized() override
    {
        slider.setBounds (0, 0, getWidth(), getHeight() - labelHeight - textBoxHeight);
        label.setBounds (0, slider.getHeight(), getWidth(), labelHeight);
    }
};


class EQComponent : public juce::Component
{
private:
    int numBands;

    struct Band
    {
        std::unique_ptr<LabelledSliderWidget> gainSlider;
        std::unique_ptr<LabelledSliderWidget> freqSlider;
        std::unique_ptr<LabelledSliderWidget> qFactorSlider;
    };

    std::vector<Band> bands;
    std::vector<int>& colX;
    std::vector<int>& rowY;

public:
    EQComponent (const int _numBands, juce::AudioProcessorValueTreeState& vts, std::vector<int>& _colX, std::vector<int>& _rowY) : colX (_colX), rowY (_rowY)
    {
        numBands = _numBands;
        colX = _colX;
        rowY = _rowY;
        for (int i = 0; i < numBands; ++i)
        {
            bands.push_back (Band());

            bands[i].gainSlider = std::make_unique<LabelledSliderWidget>("Band " + juce::String(i + 1) + " Gain", "G", vts);
            bands[i].gainSlider->setSliderStyle (Slider::SliderStyle::LinearVertical);
            addAndMakeVisible(*bands[i].gainSlider);

            bands[i].freqSlider = std::make_unique<LabelledSliderWidget>("Band " + juce::String(i + 1) + " Frequency", "F", vts);
            addAndMakeVisible(*bands[i].freqSlider);

            bands[i].qFactorSlider = std::make_unique<LabelledSliderWidget>("Band " + juce::String(i + 1) + " Q Factor", "Q", vts);
            addAndMakeVisible(*bands[i].qFactorSlider);
        }
    }

    void resized() override
    {
        for (int i = 0; i < numBands; ++i)
        {
            bands[i].gainSlider->setBounds(colX[i], rowY[0] - 200, 80, 300);
            bands[i].freqSlider->setBounds(colX[i], rowY[1], 80, 130);
            bands[i].qFactorSlider->setBounds(colX[i], rowY[2], 80, 130);
        }
    }

    void paint(juce::Graphics& g) override
    {

    }
};

class SafeequaliserAudioProcessorEditor  : public juce::AudioProcessorEditor
{
public:
    SafeequaliserAudioProcessorEditor (SafeequaliserAudioProcessor& ownerFilter, juce::AudioProcessorValueTreeState& state);
    ~SafeequaliserAudioProcessorEditor();

    //==============================================================================
    // This is just a standard Juce paint method...
    
    void sliderUpdate (Slider* slider);
    
    void updateUI();
    
    void filterControlChanged (int controlNum);

    //==============================================================================
    void paint (juce::Graphics&) override;
    void resized() override;


    std::unique_ptr<EQComponent> eqComponent;

    // This reference is provided as a quick way for your editor to
    // access the processor object that created it.
    SafeequaliserAudioProcessor& audioProcessor;

private:


    
    juce::AudioProcessorValueTreeState& vts;
};


#endif  // PLUGINEDITOR_H_INCLUDED
